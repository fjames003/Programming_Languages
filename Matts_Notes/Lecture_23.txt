------------------
Memory Management
------------------
- call stack
  - stores data for the methods/functions that are currently running
- heap
  - everything else. 

Each method call has an associated *stack frame*.

The stack contains space for the data used by the method, e.g. space
for the formal parameters and local variables.

int m(int a, int b) {
     int c = a + 1;
     int d = n(a, b, c);
     return c + d;
}

int n(int q, int r, int s) {
     int t = q + r + s + 1;
     return t;
}

main(String[] args) {
    m(5,6);
}

Initially, call stack just contains one *frame* for main:

  -------------
  String[] args    [Main's stack frame]
  -------------

When main calls m, we add a frame. Now main is suspended until m
returns.

  -------------
  int d
  int c            [m's stack frame]
  int b
  int a
  -------------
  String[] args    [Main's stack frame]
  -------------

When m calls n, we add another frame:

  -------------
  int t
  int s            [n's stack frame]
  int r 
  int q
  -------------
  int d
  int c            [m's stack frame]
  int b
  int a
  -------------
  String[] args    [Main's stack frame]
  -------------

So after n returns, the call stack looks like this:

  -------------
  int d
  int c            [m's stack frame]
  int b
  int a
  -------------
  String[] args    [Main's stack frame]
  -------------

    public static int fact(int n) {
	if(n == 0)
	    return 1;
	
	return n * fact(n-1);
    }

   ---------   
   int n = 1   [fact(1)'s stack frame]
   ---------
   int n = 2   [fact(2)'s stack frame]
   ----------
   int n = 3   [fact(3)'s stack frame]
   ----------

The call stack stores other information:
  - debugging information about the function (e.g. for *stack traces*
    generated by exceptions).
  - additional storage for temporary work
  - the *return address* of the call site, which tells us where we left
    off executing the caller function.
  - buffer overflow attacks typically work by overwriting the return
    address, with the address of some malicious code.
    When function returns, that code starts running.
  
Where are "new" objects stored?
  - We can't be sure that the object won't be used later, so it would
    be unsafe to deallocate the object's memory when the current
    method returns.
  - Instead, objects are always stored on the *heap*.  This is a
    separate area of memory that is shared across the whole program's
    execution.  A "new" expression allocates a chunk of memory from
    the heap for use by a new object.

------------------------------ Example:

class Int {
    public int val;
    Int(int val) {
	this.val = val;
    }

    public String toString() {
	return new Integer(val).toString();
    }
}

class HeapInt {
    public static void n() {
	Int x = new Int(1);
	return x;
    }
    
    public static void m(Int x) {
	Int y = x;
	Int z = n();
	y.val += z.val;
    }
    
    public static void main(String[] args) {
	Int x = new Int(5);
	m(x);
	System.out.println(x);
    }
}

----------------------------------------

          -------------
[n]       Int x = 0xA1D ----------> 0xA1D [val = 1, ...]
          -------------
	  Int z 
          Int y = 0xA0C -----+
[m]       Int x = 0xA0C -----|
          -------------      |
[main]    Int x = 0xA0C -----+----> 0xA0C [val = 5, ...]
          -------------


after n returns:

          -------------
	  Int z = 0xA1D ----------> 0xA1D [val = 1, ...]
          Int y = 0xA0C -----+
[m]       Int x = 0xA0C -----|
          -------------      |
[main]    Int x = 0xA0C -----+----> 0xA0C [val = 5, ...]
          -------------

In Java, all references point to heap locations.

C and C++ allow pointers to stack locations:

#include "stdio.h"

void zero(int * loc) {
    *loc = 0;
}

int main(void) {
    int x = 12345;
    zero(&x);
    printf("%d\n", x); // prints 0
    return 0;
}

C and C++ allow pointers to heap, but also stack and even code (which
is often stored in separate read-only part of memory "code segment").

          ---------------
[zero]    int* loc = 0xA0C -----+
          ---------------      |
[main]    int x = 12345   <----+
          ---------------

Q: In java, what can be stored on the stack?
A: primitives, references

Q: What can be stored on the heap?
A: everything.

Q: The heap also has a finite maximum size. What happens when we
   exceed it?
A: OutOfMemoryError

Manual memory bugs:
 - Dangling pointer: free an object that's still in use.
   Possibility of dangling pointer errors violates strong typing!
 - Memory leak: don't free an object that isn't still in use.

Garbage Collection:
 - runtime system periodically suspends the program
 - walks the heap.
 - marks all the locations that could still be in use
 - deletes all the the locations that can't possibly be used.

Parameters
==========

In C, ML, and Java, parameters are always passed *by value*:

Evaluate the actual argument to a value, and *copy* that value into
the formal parameter variable.

Example:

    int plus(int a, int b) {
	a += b;
	return a;
    }

    void f() {
	int x = 3;
	int y = 4;
	int z = plus(x,y);
	// x is not changed by calling plus.
	// always true. no matter what we call.
	// this is call-by-value.
    }

Call by reference: C++

    // & denotes that a and b are passed by reference
    int plus(int & a, int & b) {
      a += b;
      return a;
    }

    int main() {
    int x = 3;
    int y = 4;

    int z = plus(x,y);
    // x is now 7.

    // note: arguments to plus must be "l-values" -- expressions that can be
    // assigned to (used on the left hand side of an assignment).
    // plus(3,y) will produce a compiler error, since we can't assign to 3.
    // in particular, 3 += b does not make sense.
    

  Q: Why do we need references at all? Why not just copy objects into
     the stack like we do for primitives?
  A: Several reasons.
     Efficiency is a big one. Expensive to copy large objects.
     Side effects: imperative functions are often run to produce a
       side effect (e.g. update some object), rather than compute a
       return value. Caller won't see the effect if its made to a copy.



==================================================
Evaluation order
==================================================

Java, ML, Python, C, JavaScript all *eager*. This means:

  To evaluate a function call E1(E2, E3, ..., En)

   evaluate E1 --> f
   evaluate E2 --> A2
   evaluate E3 --> A3
   ...
   evaluate En --> An

   then, call f with arguments A2 , A3 ... An

--------- Example: What is printed by:

def plus(x,y):
  print("plus(%d,%d)" % (x,y))
  return x + y

def number(x):
  print("number(%d)" % x)
  return x

print(plus(number(1), number(2) + number(3)))

------------------

  Same thing with operators like +:

      E1 + E2

  evaluate E1 --> V1
  evaluate E2 --> V2

  Not all expressions are eager. For example, python's `and` and `or`
  operators do "short-circuiting".

     E1 and E2
  evaluate E1 --> V1
  if V1 is False, return False.
  if V1 is True, evaluate E2 --> V2

  E2 is only evluated if E1 evaluates to True.

---------- ShortCircuit.py

import random

def choose():
  x = random.choice([True, False])
  print(x)
  return x

----------------------------------------

from ShortCircuit import choose

x = choose() and choose() and choose() and choose()

# how many lines will this print out?
# depends on how many times choose() is called
# depends on the random values chosen.